/** *********************************************************************************
 *	LED/SW の表示.
 ************************************************************************************
 */
#include <stdlib.h>
#include "opcode.h"
#include "gr.h"
#include "led.h"

//	LEDの表示内容.
int	LED_acc=0;
int	LED_ea =0;
int	LED_pc =0;

//	トグルSWの設定内容.
int	SW_inp =0xaa15;


int	led_speed = 0;		// 0,1,2
int	led_trace = 1;		// 1ならLEDを毎回表示する.
int	gr_break_cnt = 0;	// gr_break()関数の呼び出しを間引きするためのカウンタ.

#define	W10 8

//					R G B
#define	LINE_COL 0x88aaee	//	枠線の色.
#define	LED_COL  0xfa0000	//  LEDの点灯色.

void gr_pset2(int x,int y,int color)
{
#if	SCREEN_X2
	x*=2;
	y*=2;
	gr_pset(x  ,y,color);
	gr_pset(x+1,y,color);y+=1;
	gr_pset(x  ,y,color);
	gr_pset(x+1,y,color);
#else
	gr_pset(x,y,color):
#endif
}


/** *********************************************************************************
 *	VRAMに書き込まれる4bit(16色)カラーから、Windowsのフルカラー色に変換するテーブル.
 ************************************************************************************
 */
int	colortab[16]={
	//R G B
	0x000000,
	0x0000ff,
	0x00ff00,
	0x00ffff,
	0xff0000,
	0xff00ff,
	0xffff00,
	0xffffff,
	0x000000,
	0x000080,
	0x008000,
	0x008080,
	0x800000,
	0x800080,
	0x808000,
	0x808080,
};
#if	0
int	colortab[16]={
	0x000000,
	0x000080,
	0x008000,
	0x008080,
	0x800000,
	0x800080,
	0x808000,
	0x808080,
	0x000000,
	0x0000ff,
	0x00ff00,
	0x00ffff,
	0xff0000,
	0xff00ff,
	0xffff00,
	0xffffff,
};
#endif
//トグルSWの表示位置（１６個分) マウス座標当たり判定用.
int	SW_rect_x[16];
int	SW_rect_y;

/** *********************************************************************************
 *	gr_break()関数の呼び出しを間引くカウント数のテーブル.
 ************************************************************************************
 */
static	int	Max_break[8]={4096,128,1,1,1,1,1,1};

/** *********************************************************************************
 *	エミュレータのOUT命令の値を受け取る.
 ************************************************************************************
 */
void VRAM_output(int adrs,int data)
{
	int x,y;				//座標(256,256)
	int rcolor,lcolor;		//2dot分の色.
	x=(adrs       & 0x7f)*2;
	y=(adrs >> 7) & 0xff;

	lcolor = colortab[(data>>4) & 7];
	rcolor = colortab[     data & 7];

	gr_pset2(x  ,y,lcolor);
	gr_pset2(x+1,y,rcolor);
}

/** *********************************************************************************
 *	エミュレータのOUT命令の値を受け取る.
 ************************************************************************************
 */
//	LED出力.
void LED_output(int acc , int ea)
{
	LED_acc = acc;
	LED_ea  = ea ;
	if(led_trace) {
		printf("LED_output( ACC=%04x: EA=%04x )\n", acc,ea);
	}
}

/** *********************************************************************************
 *	座標(x,y)に数値(num)を書く.
 ************************************************************************************
 */
void gr_putnum(int x,int y,int num)
{
	char buf[32];
	sprintf(buf,"%X",num);
	gr_puts(x+6,y-20,buf,0xffeeee,0,16);
}

/** *********************************************************************************
 *	LEDを１６本表示する.
 ************************************************************************************
 */
void led16draw(int x,int y,int w,int h,int data,int color,int cnt,char *name)
{
	int i,m=0x8000,col;
	gr_puts(x-36,y-6,name,0xffeeee,0,16);
	for(i=0;i<cnt;i++,m>>=1) {
		col=0x224400;				//消灯時のLED色.
		if(data & m) col=color;		//点灯色.

		gr_boxfill(x,y,x+w,y+h,col);		//LEDの色を描画.
		gr_box(x,y,x+w+2,y+h+2,0x00eeee);	//LED枠を描画.
		gr_putnum(x,y,15-i);				//LEDの番号を描画.

		x += (w+W10);				// 右に (w+10)ドット移動.
		if((i % 4)==3) x+=4;		// LED 4個単位で間を空ける.
		if((i % 8)==7) x+=4;		// LED 8個単位で間を空ける.
	}
}
/** *********************************************************************************
 *	トグルＳＷを１６本表示する.
 ************************************************************************************
 */
void SW_draw(int x,int y,int w,int h,int data,int color,int cnt,char *name)
{
	int i,m=0x8000,col;	//,pos;
	gr_puts(x-36,y-6,name,0xffeeee,0,16);

	for(i=0;i<cnt;i++,m>>=1) {

		gr_box(x,y,x+h+2,y+h+2,0x00eeee);
		if(data & m) {
			col=0;
			gr_boxfill(x+3,y+3	,x+3+4,y+3+16,col);
			col=0xaaeeff;
			gr_boxfill(x+3,y+3+3,x+3+4,y+3+3-16,col);
		}else{
			col=0;
			gr_boxfill(x+3,y+3+3,x+3+4,y+3+3-16,col);
			col=0x4499cc;
			gr_boxfill(x+3,y+3	,x+3+4,y+3+16,col);
		}
		gr_putnum(x,y-12,15-i);

		if( SW_rect_y == 0 ) {
			SW_rect_x[i]=x;
		}

		x += (w+W10);
		if((i % 4)==3) x+=4;
		if((i % 8)==7) x+=4;
	}

	SW_rect_y = y;
}

/** *********************************************************************************
 *	トグルＳＷの当たりチェック.
 ************************************************************************************
 */
int	SW_hitchk(int i,int mx,int my)
{
	int x,y;
	x = SW_rect_x[i]-4;
	y = SW_rect_y - 16;
	
	if((mx < x) || (mx >= (x+16)) ) return 0;
	if((my < y) || (my >= (y+32)) )return 0;
	return 1;
}
/** *********************************************************************************
 *	トグルＳＷをFLIPする.
 ************************************************************************************
 */
void SW_flip(int x,int y)
{
	int i,m=0x8000;
	int cnt=16;
	for(i=0;i<cnt;i++,m>>=1) {
		if( SW_hitchk(i,x,y) ) {
			SW_inp ^= m;
		}
	}
}
/** *********************************************************************************
 *	[SPACE]が押されたら、描画待ち時間を切り替える.
 ************************************************************************************
 */
void LED_speed_change()
{
	led_speed++;
	if(led_speed>3) led_speed=0;
}
/** *********************************************************************************
 *	[SPACE]が押されたら、描画待ち時間を切り替える.
 ************************************************************************************
 */
void LED_trace_change()
{
	led_trace^=1;
}
/** *********************************************************************************
 *	LEDの表示: メイン処理.
 ************************************************************************************
 */
int LED_draw(int pc,int draw)
{
	int rc = 0;
	LED_pc = pc;

//	if(led_trace) {
	if(draw) {
		// ========	枠を書く.
		gr_box(LED_X,LED_Y,LED_X+LED_W,LED_Y+LED_H,LINE_COL);
		// ======== ACC,EA,PCのLEDを書く.
		led16draw(LED_X+48,LED_Y+40,16,8   ,LED_acc,LED_COL,16,"ACC");
		led16draw(LED_X+48,LED_Y+40+48,16,8,LED_ea,LED_COL,16 ,"EA");
		led16draw(LED_X+48,LED_Y+40+96,16,8,LED_pc,LED_COL,16 ,"PC");

		// ========	枠を書く.
		gr_box(LED_X,LED_Y+SW_Y,LED_X+LED_W,LED_Y+SW_Y+80,LINE_COL);
		// Toggle SWの表示.
		SW_draw(LED_X+48,LED_Y+40+SW_Y,16,8,SW_inp,LED_COL,16,"SW");
		// ======== 表示待ち.
		Sleep(led_speed * 50);
		return gr_break();
	}
	// ======== 描画更新 & [ESC]が押されたら1を返す.
	gr_break_cnt++;
	if(	gr_break_cnt>= Max_break[led_speed&7] ) {
		gr_break_cnt = 0;
		rc = gr_break();
	}
	return rc;
}
/** *********************************************************************************
 *	キー(VK_*)が押されたらコールバックされる関数.
 ************************************************************************************
 */
void gr_keydown_callback(int vk_key)
{
	if(vk_key == VK_SPACE) {
		LED_speed_change();
	}
	if(vk_key == VK_UP) {
		LED_trace_change();
	}
}


/** *********************************************************************************
 *	マウスが左クリックされたらコールバックされる関数.
 ************************************************************************************
 */
void gr_mouse_callback(int x,int y)
{
//	printf("mouse %d %d\n",x,y);
	SW_flip(x,y);
}
/** *********************************************************************************
 *
 ************************************************************************************
 */
